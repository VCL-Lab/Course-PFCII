<!DOCTYPE html>
<html  dir="ltr">

    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>前沿计算实践II</title>
        <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">
        <link rel="apple-touch-icon-precomposed" href="images/apple-touch-icon.png">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/uikit/2.26.4/css/uikit.gradient.css">

        <!-- <link rel="stylesheet" href="style.css"> -->
        <link rel="stylesheet" href="https://cdn.rawgit.com/diversen/pandoc-uikit/master/style.css">
        <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />
        <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script>
        <!-- <script src="uikit.js"></script> -->
        <script src="https://cdn.rawgit.com/diversen/pandoc-uikit/master/uikit.js"></script>
        <!-- <script src="scripts.js"></script> -->
        <script src="https://cdn.rawgit.com/diversen/pandoc-uikit/master/scripts.js"></script>
        <!-- <script src="jquery.sticky-kit.js "></script> -->
        <script src="https://cdn.rawgit.com/diversen/pandoc-uikit/master/jquery.sticky-kit.js"></script>

        <meta name="generator" content="pandoc-uikit" />
                        <title>前沿计算实践II</title>
        <style type="text/css">code{white-space: pre;}</style>
                        <style type="text/css">
            pre > code.sourceCode { white-space: pre; position: relative; }
            pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
            pre > code.sourceCode > span:empty { height: 1.2em; }
            .sourceCode { overflow: visible; }
            code.sourceCode > span { color: inherit; text-decoration: inherit; }
            div.sourceCode { margin: 1em 0; }
            pre.sourceCode { margin: 0; }
            @media screen {
            div.sourceCode { overflow: auto; }
            }
            @media print {
            pre > code.sourceCode { white-space: pre-wrap; }
            pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
            }
            pre.numberSource code
              { counter-reset: source-line 0; }
            pre.numberSource code > span
              { position: relative; left: -4em; counter-increment: source-line; }
            pre.numberSource code > span > a:first-child::before
              { content: counter(source-line);
                position: relative; left: -1em; text-align: right; vertical-align: baseline;
                border: none; display: inline-block;
                -webkit-touch-callout: none; -webkit-user-select: none;
                -khtml-user-select: none; -moz-user-select: none;
                -ms-user-select: none; user-select: none;
                padding: 0 4px; width: 4em;
                color: #aaaaaa;
              }
            pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
            div.sourceCode
              {   }
            @media screen {
            pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
            }
            code span.al { color: #ff0000; } /* Alert */
            code span.an { color: #008000; } /* Annotation */
            code span.at { } /* Attribute */
            code span.bu { } /* BuiltIn */
            code span.cf { color: #0000ff; } /* ControlFlow */
            code span.ch { color: #008080; } /* Char */
            code span.cn { } /* Constant */
            code span.co { color: #008000; } /* Comment */
            code span.cv { color: #008000; } /* CommentVar */
            code span.do { color: #008000; } /* Documentation */
            code span.er { color: #ff0000; font-weight: bold; } /* Error */
            code span.ex { } /* Extension */
            code span.im { } /* Import */
            code span.in { color: #008000; } /* Information */
            code span.kw { color: #0000ff; } /* Keyword */
            code span.op { } /* Operator */
            code span.ot { color: #ff4000; } /* Other */
            code span.pp { color: #ff4000; } /* Preprocessor */
            code span.sc { color: #008080; } /* SpecialChar */
            code span.ss { color: #008080; } /* SpecialString */
            code span.st { color: #008080; } /* String */
            code span.va { } /* Variable */
            code span.vs { color: #008080; } /* VerbatimString */
            code span.wa { color: #008000; font-weight: bold; } /* Warning */
        </style>
                                               
    </head>

    <body>


        <div class="uk-container uk-container-center uk-margin-top uk-margin-large-bottom">

                        <div class="uk-grid" data-uk-grid-margin>
                <div class="uk-width-1-1">
                    <h1 class="uk-heading-large"><a href='../index.html'>前沿计算实践II</a></h1>
                                                        </div>
            </div>
            
            <div class="uk-grid" data-uk-grid-margin >          
                <div class="uk-width-medium-1-4">
                    <div class="uk-overflow-container" data-uk-sticky="{top:25,media: 768}">
                        <div class="uk-panel uk-panel-box menu-begin" >

                                                        <ul>
                                                        <li><a href="#lecture-5-pythoncpp-build-system">Lecture 5: Python+Cpp &amp; Build System</a>
                                                        <ul>
                                                        <li><a href="#python解释器">Python解释器</a></li>
                                                        <li><a href="#为什么动态解释慢">为什么动态解释慢</a></li>
                                                        <li><a href="#cython">cython</a>
                                                        <ul>
                                                        <li><a href="#什么是cython">什么是cython</a></li>
                                                        <li><a href="#原生python">原生Python</a></li>
                                                        <li><a href="#编译运行cython程序">编译运行Cython程序</a></li>
                                                        <li><a href="#加速加速">加速!加速!</a></li>
                                                        </ul></li>
                                                        <li><a href="#pybind11">pybind11</a>
                                                        <ul>
                                                        <li><a href="#其他使用python调用c的方式">其他使用python调用C++的方式</a></li>
                                                        <li><a href="#什么时候应该加速呢">什么时候应该加速呢</a></li>
                                                        <li><a href="#总结-2">总结:</a></li>
                                                        </ul></li>
                                                        <li><a href="#make">Make</a></li>
                                                        <li><a href="#cmake">CMAKE</a>
                                                        <ul>
                                                        <li><a href="#cmake-命令基础">CMAKE 命令基础</a></li>
                                                        <li><a href="#生成configure文件">生成Configure文件</a></li>
                                                        <li><a href="#包查询和包管理">包查询和包管理</a></li>
                                                        </ul></li>
                                                        </ul></li>
                                                        <li><a href="#参考链接">参考链接</a></li>
                                                        </ul>
                            
                        </div>
                    </div>
                </div>

                <div class="uk-width-medium-3-4">
<h1 id="lecture-5-pythoncpp-build-system">Lecture 5: Python+Cpp &amp; Build System</h1>
<p>Python写起来非常方便, 但面对大量for循环的时候, 执行速度有些捉急. 原因在于, python是一种动态类型语言, 在运行期间才去做数据类型检查, 这样效率就很低(尤其是大规模for循环的时候).</p>
<p>相比而言, C/C++每个变量的类型都是事先给定的, 通过编译生成二进制可执行文件. 相比与python, C/C++效率比较高, 大规模for循环执行速度很快.</p>
<p>既然python的短板在于速度, 所以, 为了给python加速, 能否在Python中调用C/C++的代码?</p>
<h3 id="python解释器">Python解释器</h3>
<p>当我们编写Python代码时，我们得到的是一个包含Python代码的以<code>.py</code>为扩展名的文本文件。要运行代码，就需要Python解释器去执行<code>.py</code>文件。</p>
<p>(你给我翻译翻译, 什么叫python代码)</p>
<h4 id="cpython">CPython</h4>
<p>当我们从<a href="https://www.python.org/">Python官方网站</a>下载并安装好Python后，我们就直接获得了一个官方版本的解释器：<code>CPython</code>。这个解释器是用C语言开发的，所以叫<code>CPython</code>。在命令行下运行<code>python</code>就是启动<code>CPython</code>解释器。<code>CPython</code>是使用最广的Python解释器。</p>
<p>虽然CPython效率低, 但是如果用它去调用C/C++代码, 效果还是挺好的. 像numpy之类的数学运算库, 很多都是用C/C++写的. 这样既能利用python简洁的语法, 又能利用C/C++高效的执行速度, (赢了两次, 赢麻了). 有些情况下numpy效率比自己写C/C++还高, 因为numpy利用了CPU指令集优化和多核并行计算(又赢了两次).</p>
<p>我们今天要讲的Python调用C/C++, 都是基于CPython解释器的.</p>
<h4 id="ironpython">IronPython</h4>
<p><code>IronPython</code>和<code>Jython</code>类似，只不过<code>IronPython</code>是运行在微软<code>.Net</code>平台上的<code>Python</code>解释器，可以直接把Python代码编译成.Net的字节码。缺点在于, 因为<code>numpy</code>等常用的库都是用<code>C/C++</code>编译的, 所以在<code>IronPython</code>中调用<code>numpy</code>等第三方库非常不方便.</p>
<h4 id="jython">Jython</h4>
<p><code>Jython</code>是运行在<code>Java</code>平台上的<code>Python</code>解释器，可以直接把<code>Python</code>代码编译成<code>Java</code>字节码执行。<code>Jython</code>的好处在于能够调用<code>Java</code>相关的库, 坏处跟<code>IronPython</code>一样.</p>
<h4 id="pypy">PyPy</h4>
<p>PyPy一个基于Python的解释器，也就是用python解释.py. 它的目标是执行速度。PyPy采用<a href="http://en.wikipedia.org/wiki/Just-in-time_compilation">JIT技术</a>，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。</p>
<h3 id="为什么动态解释慢">为什么动态解释慢</h3>
<p>假设我们有一个简单的python函数</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add(x, y):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> y</span></code></pre></div>
<p>然后<code>CPython</code>执行起来大概是这个样子(伪代码)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> instance_has_method<span class="op">(</span>x<span class="op">,</span> &#39;__add__&#39;<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// x.__add__ 里面又有一大堆针对不同类型的 y 的判断</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> call<span class="op">(</span>x<span class="op">,</span> &#39;__add__&#39;<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> isinstance_has_method<span class="op">(</span>super_class<span class="op">(</span>x<span class="op">),</span> &#39;__add__&#39; <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> call<span class="op">(</span>super_class<span class="op">,</span> &#39;__add__&#39;<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> isinstance<span class="op">(</span>x<span class="op">,</span> str<span class="op">)</span> and isinstance<span class="op">(</span>y<span class="op">,</span> str<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> concat_str<span class="op">(</span>x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> isinstance<span class="op">(</span>x<span class="op">,</span> <span class="dt">float</span><span class="op">)</span> and isinstance<span class="op">(</span>y<span class="op">,</span> <span class="dt">float</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> add_float<span class="op">(</span>x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> isinstance<span class="op">(</span>x<span class="op">,</span> <span class="dt">int</span><span class="op">)</span> and isinstance<span class="op">(</span>y<span class="op">,</span> <span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> add_int<span class="op">(</span>x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">...</span></span></code></pre></div>
<p>因为Python的动态类型, 一个简单的函数, 要做很多次类型判断. 这还没完，你以为里面把两个整数相加的函数，就是 C 语言里面的 x + y 么? No.</p>
<p>Python里万物皆为对象, 实际上Python里的int大概是这样一个结构体(伪代码).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    prev_gc_obj <span class="op">*</span>obj</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    next_gc_obj <span class="op">*</span>obj</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    type IntType</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    value IntValue</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span> other fields</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>每个 int 都是这样的结构体，还是动态分配出来放在 heap 上的，里面的 value 还不能变，也就是说你算 1000 这个结构体加 1000 这个结构体，需要在heap里malloc出来 2000 这个结构体. 计算结果用完以后, 还要进行内存回收. (执行这么多操作, 速度肯定不行)</p>
<p>所以, 如果能够静态编译执行+指定变量的类型, 将大幅提升执行速度.</p>
<h2 id="cython">cython</h2>
<h3 id="什么是cython">什么是cython</h3>
<p>cython是一种新的编程语言, 它的语法基于python, 但是融入了一些C/C++的语法. 比如说, cython里可以指定变量类型, 或是使用一些C++里的stl库(比如使用<code>std::vector</code>), 或是调用你自己写的C/C++函数.</p>
<p>注意: Cython不是CPython!</p>
<h3 id="原生python">原生Python</h3>
<p>我们有一个<code>RawPython.py</code></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> sqrt</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> func(n):</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        res <span class="op">=</span> res <span class="op">+</span> <span class="fl">1.0</span> <span class="op">/</span> sqrt(i)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main():</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> time.time()</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> func(<span class="dv">30000000</span>)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;res = </span><span class="sc">{</span>res<span class="sc">}</span><span class="ss">, use time </span><span class="sc">{</span>time<span class="sc">.</span>time() <span class="op">-</span> start<span class="sc">:.5}</span><span class="ss">&quot;</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    main()</span></code></pre></div>
<p>我们先使用Python原生方式来执行看一下需要多少时间。</p>
<h3 id="编译运行cython程序">编译运行Cython程序</h3>
<p>首先, 把一个cython程序转化成<code>.c/.cpp</code>文件, 然后用<code>C/C++</code>编译器, 编译生成二进制文件. 在Windows下, 我们需要安装Visual Studio/mingw等编译工具. 在Linux或是Mac下, 我们需要安装<code>gcc</code>, <code>clang</code> 等编译工具.</p>
<ol type="1">
<li><p>通过<code>pip</code>安装cython</p>
<pre class="shell"><code>pip install cython</code></pre></li>
<li><p>把<code>RawPython.py</code>重命名为<code>RawPython1.pyx</code></p></li>
<li><p>(1)用setup.py编译</p>
<p>增加一个<code>setup.py</code>, 添加以下内容. 这里language_level的意思是, 使用Python 3.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> distutils.core <span class="im">import</span> setup</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Cython.Build <span class="im">import</span> cythonize</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>setup(</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    ext_modules <span class="op">=</span> cythonize(<span class="st">&#39;RawPython1.pyx&#39;</span>, language_level<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<p>把Python编译为二进制代码</p>
<pre class="shell"><code>python setup.py build_ext --inplace</code></pre>
<p>然后, 我们发现当前目录下多了RawPython1.c(由<code>.pyx</code>转化生成), 和<code>RawPython1.pyd</code>(由.c编译生成的二进制文件).</p>
<p>(2)直接在命令行编译(以<code>gcc</code>为例)</p>
<pre class="shell"><code>cython RawPython1.pyx
gcc -shared -pthread -fPIC -fwrapv -O2 -Wall -fno-strict-aliasing -I/usr/include/python3.x -o RawPython1.so RawPython1.c</code></pre>
<p>第一句是把.pyx转化成.c, 第二句是用<code>gcc</code>编译+链接.</p></li>
<li><p>在当前目录下, 运行</p>
<pre class="shell"><code>python -c &quot;import RawPython1; RawPython1.main()&quot;</code></pre>
<p>我们可以导入编译好的RawPython1模块, 然后在Python中调用执行.</p></li>
</ol>
<p>由以上的步骤的执行结果来看，并没有提高太多，只大概提高了一倍的速度，这是因为Python的运行速度慢除了因为是解释执行以外还有一个最重要的原因是Python是动态类型语言，每个变量在运行前是不知道类型是什么的，所以即便编译为二进制代码同样速度不会太快，这时候我们需要深度使用<code>Cython</code>来给Python提速了，就是使用<code>Cython</code>来指定Python的数据类型。</p>
<h3 id="加速加速">加速!加速!</h3>
<h4 id="指定变量类型">指定变量类型</h4>
<p>cython的好处是, 可以像C语言一样, 显式地给变量指定类型. 所以, 我们在<code>cython</code>的函数中, 加入循环变量的类型.</p>
<p>然后, 用C语言中的sqrt实现开方操作.</p>
<pre class="cython"><code>def func(int n):
    cdef double res = 0
    cdef int i, num = n
    for i in range(1, num):
        res = res + 1.0 / sqrt(i)
    return res</code></pre>
<p>但是, python中<code>math.sqrt</code>方法, 返回值是一个<code>Python</code>的<code>float</code>对象, 这样效率还是比较低.</p>
<p>为了, 我们能否使用C语言的sqrt函数? 当然可以~</p>
<p><code>Cython</code>对一些常用的C函数/C++类做了包装, 可以直接在Cython里进行调用.</p>
<p>我们把开头的</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> sqrt</span></code></pre></div>
<p>换成</p>
<pre class="cython"><code>from libc.math cimport sqrt</code></pre>
<p>再按照上面的方式编译运行, 发现速度提高了不少.</p>
<h4 id="cython调用cc">Cython调用C/C++</h4>
<p>既然C/C++比较高效, 我们能否直接用cython调用C/C++呢? 就是用C语言重写一遍这个函数, 然后在cython里进行调用.</p>
<p>首先写一段对应的C语言版本</p>
<p>usefunc.h</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma once</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;math.h&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> c_func<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> result <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>i<span class="op">=</span><span class="dv">1</span><span class="op">;</span> i<span class="op">&lt;</span>n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> result <span class="op">+</span> sqrt<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>然后, 我们在<code>Cython</code>中, 引入这个头文件, 然后调用这个函数</p>
<pre class="cython"><code>cdef extern from &quot;usecfunc.h&quot;:
    cdef double c_func(int n)
import time

def func(int n):
    return c_func(n)

def main():
    start = time.time()
    res = func(30000000)
    print(f&quot;res = {res}, use time {time.time() - start:.5}&quot;)</code></pre>
<h4 id="在cython中使用numpy">在Cython中使用numpy</h4>
<p>在<code>Cython</code>中, 我们可以调用<code>numpy</code>. 但是, 如果直接按照数组下标访问, 我们还需要动态判断<code>numpy</code>数据的类型, 这样效率就比较低.</p>
<pre class="cython"><code>import numpy as np
cimport numpy as np
from libc.math cimport sqrt
import time

def func(int n):
    cdef np.ndarray arr = np.empty(n, dtype=np.float64)
    cdef int i, num = n 
    for i in range(1, num):
        arr[i] = 1.0 / sqrt(i)
    return arr

def main():
    start = time.time()
    res = func(30000000)
    print(f&quot;len(res) = {len(res)}, use time {time.time() - start:.5}&quot;)</code></pre>
<p>解释:</p>
<pre class="cython"><code>cimport numpy as np</code></pre>
<p>这一句的意思是, 我们可以使用<code>numpy</code>的C/C++接口(指定数据类型, 数组维度等).</p>
<pre class="cython"><code>import numpy as np</code></pre>
<p>这一句的意思是, 我们也可以使用<code>numpy</code>的Python接口(np.array, np.linspace等). <code>Cython</code>在内部处理这种模糊性，这样用户就不需要使用不同的名称.</p>
<p>在编译的时候, 我们还需要修改setup.py, 引入<code>numpy</code>的头文件.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> distutils.core <span class="im">import</span> setup, Extension</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> Cython.Build <span class="im">import</span> cythonize</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>setup(ext_modules <span class="op">=</span> cythonize(</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    Extension(<span class="st">&quot;RawPython4&quot;</span>, [<span class="st">&quot;RawPython4.pyx&quot;</span>],include_dirs<span class="op">=</span>[np.get_include()],), </span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    language_level<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<h5 id="加速加速-1">加速!加速!</h5>
<p>上面的代码, 还是能够进一步加速的</p>
<ol type="1">
<li><p>可以指定<code>numpy</code>数组的数据类型和维度, 这样就不用动态判断数据类型了. 实际生成的代码, 就是按C语言里按照数组下标来访问.</p></li>
<li><p>在使用numpy数组时, 还要同时做数组越界检查. 如果我们确定自己的程序不会越界, 可以关闭数组越界检测.</p></li>
<li><p>Python还支持负数下标访问, 也就是从后往前的第<code>i</code>个. 为了做负数下标访问, 也需要一个额外的if..else..来判断. 如果我们用不到这个功能, 也可以关掉.</p></li>
<li><p>Python还会做除以0的检查, 我们并不会做除以0的事情, 关掉.</p></li>
<li><p>相关的检查也关掉.</p></li>
</ol>
<p>最终加速的程序如下:</p>
<pre class="cython"><code>import numpy as np
cimport numpy as np
from libc.math cimport sqrt
import time
cimport cython

@cython.boundscheck(False)         # 关闭数组下标越界
@cython.wraparound(False)          # 关闭负索引
@cython.cdivision(True)            # 关闭除0检查
@cython.initializedcheck(False)    # 关闭检查内存视图是否初始化
def func(int n):
    cdef np.ndarray[np.float64_t, ndim=1] arr = np.empty(n, dtype=np.float64)
    cdef int i, num = n 
    for i in range(1, num):
        arr[i] = 1.0 / sqrt(i)
    return arr

def main():
    start = time.time()
    res = func(30000000)
    print(f&quot;len(res) = {len(res)}, use time {time.time() - start:.5}&quot;)</code></pre>
<pre class="cython"><code>cdef np.ndarray[np.float64_t, ndim=1] arr = np.empty(n, dtype=np.float64)</code></pre>
<p>这一句的意思是, 我们创建numpy数组时, 手动指定变量类型和数组维度.</p>
<p>上面是对这一个函数关闭数组下标越界, 负索引, 除0检查, 内存视图是否初始化等. 我们也可以在全局范围内设置, 即在.pyx文件的头部, 加上注释</p>
<pre class="cython"><code># cython: boundscheck=False
# cython: wraparound=False
# cython: cdivision=True
# cython: initializedcheck=False</code></pre>
<p>也可以用这种写法:</p>
<pre class="cython"><code>with cython.cdivision(True):
    # do something here</code></pre>
<h4 id="其他">其他</h4>
<p>cython吸收了很多C/C++的语法, 也包括指针和引用. 也可以把一个struct/class从C++传给Cython.</p>
<h4 id="总结">总结</h4>
<p>Cython的语法与Python类似, 同时引入了一些C/C++的特性, 比如指定变量类型等. 同时, Cython还可以调用C/C++的函数.</p>
<p>Cython的特点在于, 如果没有指定变量类型, 执行效率跟Python差不多. 指定好类型后, 执行效率才会比较高.</p>
<p>更多文档可以参考Cython官方文档 http://docs.cython.org/en/latest/index.html</p>
<h2 id="pybind11">pybind11</h2>
<p><code>Cython</code>是一种类<code>Python</code>的语言, 但是<code>pybind11</code>是基于<code>C++</code>的. 我们在.cpp文件中引入pybind11, 定义python程序入口, 然后编译执行就好了.</p>
<p>从官网的说明中看到pybind11的几个特点</p>
<ul>
<li>轻量级头文件库</li>
<li>目标和语法类似于优秀的Boost.python库</li>
<li>用于为python绑定c++代码</li>
</ul>
<h4 id="安装">安装</h4>
<p>可以执行<code>pip install pybind11</code>安装 pybind11 (万能的pip)</p>
<p>也可以用Visual Studio + vcpkg+CMake来安装(yhy之后会讲).</p>
<h4 id="简单的例子">简单的例子</h4>
<div class="sourceCode" id="cb23"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;pybind11/pybind11.h&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> py <span class="op">=</span> pybind11<span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> add_func<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> i <span class="op">+</span> j<span class="op">;</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>PYBIND11_MODULE<span class="op">(</span>example<span class="op">,</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    m<span class="op">.</span>doc<span class="op">()</span> <span class="op">=</span> <span class="st">&quot;pybind11 example plugin&quot;</span><span class="op">;</span>  <span class="co">//可选，说明这个模块是做什么的</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    m<span class="op">.</span>def<span class="op">(</span><span class="st">&quot;add_func&quot;</span><span class="op">,</span> <span class="op">&amp;</span>add_func<span class="op">,</span> <span class="st">&quot;A function which adds two numbers&quot;</span><span class="op">);</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>首先引入pybind11的头文件, 然后用PYBIND11_MODULE声明.</p>
<ul>
<li><p>example：模型名，切记不需要引号. 之后可以在python中执行<code>import example</code></p></li>
<li><p>m：可以理解成模块对象, 用于给Python提供接口</p></li>
<li><p>m.doc()：help说明</p></li>
<li><p>m.def：用来注册函数和Python打通界限</p></li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>m<span class="op">.</span>def<span class="op">(</span> <span class="st">&quot;给python调用方法名&quot;</span>， <span class="op">&amp;</span>实际操作的函数， <span class="st">&quot;函数功能说明&quot;</span> <span class="op">).</span> <span class="co">//其中函数功能说明为可选</span></span></code></pre></div>
<h4 id="编译运行">编译&amp;运行</h4>
<p>pybind11只有头文件，所以只要在代码中增加相应的头文件, 就可以使用pybind11了.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;pybind11/pybind11.h&gt;</span></span></code></pre></div>
<ol type="1">
<li>在Linux下, 可以执行这样的命令来编译:</li>
</ol>
<pre class="shell"><code> c++ -O3 -Wall -shared -std=c++11 -fPIC $(python3 -m pybind11 --includes) example.cpp -o example$(python3-config --extension-suffix)</code></pre>
<ol start="2" type="1">
<li>我们也可以用setup.py来编译(在Windows下, 需要Visual Studio或mingw等编译工具; 在Linux或是Mac下, 需要gcc或clang等编译工具)</li>
</ol>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> setuptools <span class="im">import</span> setup, Extension</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pybind11</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>functions_module <span class="op">=</span> Extension(</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    name<span class="op">=</span><span class="st">&#39;example&#39;</span>,</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    sources<span class="op">=</span>[<span class="st">&#39;example.cpp&#39;</span>],</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    include_dirs<span class="op">=</span>[pybind11.get_include()],</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>setup(ext_modules<span class="op">=</span>[functions_module])</span></code></pre></div>
<p>然后运行下面的命令, 就可以编译了</p>
<pre class="shell"><code>python setup.py build_ext --inplace</code></pre>
<p>在python中进行调用</p>
<pre class="shell"><code>python -c &quot;import example; print(example.add_func(200, 33))&quot;</code></pre>
<h4 id="在pybind11中指定函数参数">在pybind11中指定函数参数</h4>
<p>通过简单的代码修改，就可以通知Python参数名称</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>m<span class="op">.</span>def<span class="op">(</span><span class="st">&quot;add&quot;</span><span class="op">,</span> <span class="op">&amp;</span>add<span class="op">,</span> <span class="st">&quot;A function which adds two numbers&quot;</span><span class="op">,</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>      py<span class="op">::</span>arg<span class="op">(</span><span class="st">&quot;i&quot;</span><span class="op">),</span> py<span class="op">::</span>arg<span class="op">(</span><span class="st">&quot;j&quot;</span><span class="op">));</span></span></code></pre></div>
<p>也可以指定默认参数</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">int</span> j <span class="op">=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> i <span class="op">+</span> j<span class="op">;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>在<code>PYBIND11_MODULE</code>中指定默认参数</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>m<span class="op">.</span>def<span class="op">(</span><span class="st">&quot;add&quot;</span><span class="op">,</span> <span class="op">&amp;</span>add<span class="op">,</span> <span class="st">&quot;A function which adds two numbers&quot;</span><span class="op">,</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>      py<span class="op">::</span>arg<span class="op">(</span><span class="st">&quot;i&quot;</span><span class="op">)</span> <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> py<span class="op">::</span>arg<span class="op">(</span><span class="st">&quot;j&quot;</span><span class="op">)</span> <span class="op">=</span> <span class="dv">2</span><span class="op">);</span></span></code></pre></div>
<h4 id="为python方法添加变量">为Python方法添加变量</h4>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>PYBIND11_MODULE<span class="op">(</span>example<span class="op">,</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    m<span class="op">.</span>attr<span class="op">(</span><span class="st">&quot;the_answer&quot;</span><span class="op">)</span> <span class="op">=</span> <span class="dv">23333</span><span class="op">;</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    py<span class="op">::</span>object world <span class="op">=</span> py<span class="op">::</span>cast<span class="op">(</span><span class="st">&quot;World&quot;</span><span class="op">);</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    m<span class="op">.</span>attr<span class="op">(</span><span class="st">&quot;what&quot;</span><span class="op">)</span> <span class="op">=</span> world<span class="op">;</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>对于字符串, 需要用<code>py::cast</code>将其转化为Python对象.</p>
<p>然后在Python中, 可以访问<code>the_answer</code>和<code>what</code>对象</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> example</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span>example.the_answer</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="dv">42</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span>example.what</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="co">&#39;World&#39;</span></span></code></pre></div>
<h4 id="在cpp文件中调用python方法">在cpp文件中调用python方法</h4>
<p>因为python万物皆为对象, 因此我们可以用<code>py::object</code> 来保存Python中的变量/方法/模块等.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>py<span class="op">::</span>object os <span class="op">=</span> py<span class="op">::</span><span class="va">module_</span><span class="op">::</span><span class="kw">import</span><span class="op">(</span><span class="st">&quot;os&quot;</span><span class="op">);</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>py<span class="op">::</span>object makedirs <span class="op">=</span> os<span class="op">.</span>attr<span class="op">(</span><span class="st">&quot;makedirs&quot;</span><span class="op">);</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>makedirs<span class="op">(</span><span class="st">&quot;/tmp/path/to/somewhere&quot;</span><span class="op">);</span></span></code></pre></div>
<p>这就相当于在Python里执行了</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>makedirs <span class="op">=</span> os.makedirs</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>makedirs(<span class="st">&quot;/tmp/path/to/somewhere&quot;</span>)</span></code></pre></div>
<h4 id="用pybind11使用python-list">用pybind11使用python list</h4>
<p>我们可以直接传入python的list</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_list<span class="op">(</span>py<span class="op">::</span>list my_list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> item <span class="op">:</span> my_list<span class="op">)</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>       py<span class="op">::</span>print<span class="op">(</span>item<span class="op">);</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>PYBIND11_MODULE<span class="op">(</span>example<span class="op">,</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    m<span class="op">.</span>def<span class="op">(</span><span class="st">&quot;print_list&quot;</span><span class="op">,</span> <span class="op">&amp;</span>print_list<span class="op">,</span> <span class="st">&quot;function to print list&quot;</span><span class="op">,</span> py<span class="op">::</span>arg<span class="op">(</span><span class="st">&quot;my_list&quot;</span><span class="op">));</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>在Python里跑一下这个程序,</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span><span class="im">import</span> example</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span>result <span class="op">=</span> example.print_list([<span class="dv">2</span>, <span class="dv">23</span>, <span class="dv">233</span>])</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> </span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="dv">23</span> </span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="dv">233</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span><span class="bu">print</span>(result)</span></code></pre></div>
<p>这个函数也可以用<code>std::vector&lt;int&gt;</code>作为参数. 为什么可以这样做呢? pybind11可以自动将python list对象, 复制构造为<code>std::vector&lt;int&gt;</code>. 在返回的时候, 又自动地把<code>std::vector</code>转化为Python中的list. 代码如下:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;pybind11/pybind11.h&gt;</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;pybind11/stl.h&gt;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> print_list2<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span> my_list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> x <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;();</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> item <span class="op">:</span> my_list<span class="op">){</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>        x<span class="op">.</span>push_back<span class="op">(</span>item <span class="op">+</span> <span class="dv">233</span><span class="op">);</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>PYBIND11_MODULE<span class="op">(</span>example<span class="op">,</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    m<span class="op">.</span>def<span class="op">(</span><span class="st">&quot;print_list2&quot;</span><span class="op">,</span> <span class="op">&amp;</span>print_list2<span class="op">,</span> <span class="st">&quot;help message&quot;</span><span class="op">,</span> py<span class="op">::</span>args<span class="op">(</span><span class="st">&quot;my_list&quot;</span><span class="op">));</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="用pybind11使用numpy">用pybind11使用numpy</h4>
<p>因为numpy比较好用, 所以如果能够把numpy数组作为参数传给pybind11, 那就非常香了. 代码如下(一大段)</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;pybind11/pybind11.h&gt;</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;pybind11/numpy.h&gt;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>py<span class="op">::</span><span class="dt">array_t</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> add_arrays<span class="op">(</span>py<span class="op">::</span><span class="dt">array_t</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> input1<span class="op">,</span> py<span class="op">::</span><span class="dt">array_t</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> input2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    py<span class="op">::</span>buffer_info buf1 <span class="op">=</span> input1<span class="op">.</span>request<span class="op">(),</span> buf2 <span class="op">=</span> input2<span class="op">.</span>request<span class="op">();</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>buf1<span class="op">.</span>ndim <span class="op">!=</span> <span class="dv">1</span> <span class="op">||</span> buf2<span class="op">.</span>ndim <span class="op">!=</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">&quot;Number of dimensions must be one&quot;</span><span class="op">);</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>buf1<span class="op">.</span>size <span class="op">!=</span> buf2<span class="op">.</span>size<span class="op">)</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">&quot;Input shapes must match&quot;</span><span class="op">);</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* No pointer is passed, so NumPy will allocate the buffer */</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> result <span class="op">=</span> py<span class="op">::</span><span class="dt">array_t</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>buf1<span class="op">.</span>size<span class="op">);</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>    py<span class="op">::</span>buffer_info buf3 <span class="op">=</span> result<span class="op">.</span>request<span class="op">();</span></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="op">*</span>ptr1 <span class="op">=</span> <span class="op">(</span><span class="dt">double</span> <span class="op">*)</span> buf1<span class="op">.</span>ptr<span class="op">,</span></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>           <span class="op">*</span>ptr2 <span class="op">=</span> <span class="op">(</span><span class="dt">double</span> <span class="op">*)</span> buf2<span class="op">.</span>ptr<span class="op">,</span></span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>           <span class="op">*</span>ptr3 <span class="op">=</span> <span class="op">(</span><span class="dt">double</span> <span class="op">*)</span> buf3<span class="op">.</span>ptr<span class="op">;</span></span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> idx <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> idx <span class="op">&lt;</span> buf1<span class="op">.</span>shape<span class="op">[</span><span class="dv">0</span><span class="op">];</span> idx<span class="op">++)</span></span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>        ptr3<span class="op">[</span>idx<span class="op">]</span> <span class="op">=</span> ptr1<span class="op">[</span>idx<span class="op">]</span> <span class="op">+</span> ptr2<span class="op">[</span>idx<span class="op">];</span></span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>m<span class="op">.</span>def<span class="op">(</span><span class="st">&quot;add_arrays&quot;</span><span class="op">,</span> <span class="op">&amp;</span>add_arrays<span class="op">,</span> <span class="st">&quot;Add two NumPy arrays&quot;</span><span class="op">);</span></span></code></pre></div>
<p>先把numpy的指针拿出来, 然后在指针上进行操作.</p>
<p>我们在Python里测试如下:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span><span class="im">import</span> example</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span>x <span class="op">=</span> np.ones(<span class="dv">3</span>)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span>y <span class="op">=</span> np.ones(<span class="dv">3</span>)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span>z <span class="op">=</span> example.add_arrays(x, y)</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span><span class="bu">print</span>(<span class="bu">type</span>(z))</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span><span class="kw">class</span> <span class="st">&#39;numpy.ndarray&#39;</span><span class="op">&gt;</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span><span class="bu">print</span>(z)</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>array([<span class="fl">2.</span>, <span class="fl">2.</span>, <span class="fl">2.</span>])</span></code></pre></div>
<h4 id="总结-1">总结</h4>
<p>pybind11在C++下使用, 可以为Python程序提供C++接口. 同时, pybind11也支持传入python list, numpy等对象.</p>
<p>更多文档可以参考pybind11官方文档 https://pybind11.readthedocs.io/en/stable/</p>
<h3 id="其他使用python调用c的方式">其他使用python调用C++的方式</h3>
<ol type="1">
<li>CPython会自带一个Python.h, 我们可以在C/C++中引入这个头文件, 然后编译生成动态链接库. 但是, 直接调用Python.h写起来有一点点麻烦.</li>
<li>boost是一个C++库, 对Python.h做了封装, 但整个boost库比较庞大, 而且相关的文档不太友好.</li>
<li>swig(Simplified Wrapper and Interface Generator), 用特定的语法声明C/C++函数/变量. (之前tensorlfow用的就是这个, 但现在改成pybind11了)</li>
<li>a</li>
<li>etc</li>
</ol>
<h3 id="什么时候应该加速呢">什么时候应该加速呢</h3>
<p>用Python开发比较简洁, 用C++开发写起来有些麻烦.</p>
<p>在写python时, 我们可以通过Profile等耗时分析工具, 找出比较用时的代码块, 对这一块用C++进行优化. 没必要优化所有的部分.</p>
<h3 id="总结-2">总结:</h3>
<p>Cython或是pybind11只做三件事: 加速, 加速, 还是加速. 在需要大量计算, 比较耗时的地方, 我们可以用C/C++来实现, 这样有助于提升整个Python程序的执行速度.</p>
<p>加速python还有一些其他的方法, 比如用numpy的向量化操作代替for循环, 使用jit即时编译等.</p>
<h2 id="make">Make</h2>
<p>当我们日常工作时，常常需要写一些与代码无关的事情。比如代码写完了，需要用命令行将其编译和连接，或者将一个代码的运行结果或输出放到另一个代码能找到的位置。这些繁琐的事情每一件都可以用脚本完成，但是如果要手动做这些事情会显得过于繁琐，此时我们一般使用Build System来完成这些事情。</p>
<p>Build System要完成的工作很简单，你告诉它你要生成什么文件(<code>Target</code>)，生成的时候要使用哪些文件(依赖项，<code>Prerequisites</code>)， 生成时使用的命令(<code>Recipe</code>)。此外，在你执行生成命令时，他会帮你检查依赖项是否有更新，如果没有就自动省略这次生成。</p>
<p>Linux下最常用的Build System是<code>make</code>。其模式非常简单，只需要在当前文件夹下创建一个<code>Makefile</code>文件，并在其中给出你的目标，依赖项和生成命令。一个例子如下</p>
<pre class="mak"><code>paper.pdf: paper.tex plot-data.png
    pdflatex paper.tex

plot-%.png: %.dat plot.py
    python3 plot.py -i $*.dat -o $@</code></pre>
<p>在这里，每个无缩进的行给出了一个<code>target</code>（冒号左侧）和它依赖的源（冒号右侧）。缩进里给出了target的生成命令。如果我们在bash里键入<code>make</code>，会默认生成第一个目标，如果要指定生成哪个target，则需要后面加上target名字作为参数。</p>
<p>所以我们平常看到的<code>make install</code>和<code>make clean</code>实际上是一个叫<code>install</code>、<code>clean</code>的target。<code>install</code>一般什么也不生成，只是把之前生成的东西拷贝到用户命令行能找到的目录下，而<code>clean</code>一般是清除所有的生成内容(比如下面)。</p>
<pre class="mak"><code>clean: 
    rm paper.pdf plot-*.png</code></pre>
<p>回到上面的例子，这里我们默认生成的是<code>paper.pdf</code>，其依赖项是一个<code>tex</code>文件和一个<code>png</code>文件。但是我们发现<code>png</code>文件本身也不是源文件，而是其他文件生成的。当我们执行<code>make</code>时，它会先帮我们用第二个规则生成<code>plot-data.png</code>。这里<code>plot-%.png</code>称为一个<code>pattern rule</code>，其特点就是使用<code>%</code>作为一个<code>pattern</code>，target中的<code>%</code>可以和文件名的一部分匹配，而依赖项中的<code>%</code>会保持和target中的一致。所以生成<code>plot-data.png</code>依赖于<code>data.dat</code>。</p>
<p>make的recipe部分会使用类似于<code>bash</code>的默认变量，比如<code>$@</code>等，但是含义和bash有一定的区别。比如<code>$@</code>代指target的名字，<code>$?</code>代指变化了的依赖项等。一个例子是常用的<code>make print</code>命令打印变化</p>
<pre class="mak"><code>print: *.tex *.dat *.py
    echo $?
    touch print</code></pre>
<p>这里我们创建了一个空文件<code>print</code>，这是因为<code>$?</code>输出的是相对于<code>target</code>更新的依赖项，如果我们只把<code>print</code>当作命令而不创建结果，就没有参照，从而make会输出全部的依赖项。</p>
<p>有时候我们的项目组织是递归构造的，可能根目录的<code>make</code>依赖于子目录的<code>make</code>。这时也只需要在子目录建立一个<code>Makefile</code>，并在根目录使用</p>
<pre class="mak"><code>$(MAKE) -C xxx</code></pre>
<p>其中<code>$(MAKE)</code>是make命令的另一种写法，但是可以并行调用，<code>-C</code>选项表示读取<code>Makefile</code>之前先把目录更换过去，<code>xxx</code>是目录名称。</p>
<p>make中还可以使用通配符，定义变量，给变量加修饰等等，但是我们暂时不在这里展开了，因为小的项目不会用到这些复杂的命令，大的项目手写make又是几乎不可能的，故而我们只需要保证自己能看懂基础的语法和命令即可。</p>
<p>需要再次说明，<code>make</code>只是Build System中的一种，并且是在Unix-like的操作系统上常用的。Windows上Visual Studio的sln也有类似的功能。</p>
<h2 id="cmake">CMAKE</h2>
<p>CMAKE本身不属于Build System，但是它能生成各种Build System脚本，比如make, sln。故而其特点是跨平台，跨语言的。我们常见的配置命令顺序是</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode bash"><code class="sourceCode syn"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">$</span> <span class="fu">mkdir</span> build</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="kw">$</span> <span class="bu">cd</span> build</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="kw">$</span> <span class="fu">cmake</span> ..</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="kw">$</span> <span class="fu">make</span></span></code></pre></div>
<p>这里我们手动创建了一个<code>build</code>文件夹，这是因为<code>cmake</code>在创建<code>make</code>文件时，会产生大量的中间文件，如果直接在本文件夹内执行虽然没有什么问题，但是会污染环境。<code>build</code>文件夹会用来存放cmake的输出，而<code>cmake ..</code>表示真正的源码是build文件夹的父亲目录。运行<code>cmake ..</code>后会生成<code>Makefile</code>，之后就可以执行<code>make</code>了。</p>
<p>这里<code>build</code>可以替换成任意一个文件夹名，一般将不创建文件夹，直接在根目录下执行cmake的方法称为<code>in-source-build</code>，而在其他文件夹执行<code>cmake</code>的方法称为<code>out-of-source</code>。</p>
<p>作为跨平台的系统，CMAKE对不同平台的指令进行了抽象，比如上面的bash脚本也可以用CMake写成跨平台的版本</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode bash"><code class="sourceCode syn"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="fu">cmake</span> -E make_directory build</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="fu">cmake</span> -E chdir build cmake ..</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="fu">cmake</span> --build build</span></code></pre></div>
<p>其中<code>cmake --build build</code>等价于在<code>build</code>文件夹下执行<code>make</code>(Linux)或者在<code>build</code>文件夹下用Visual Studio生成项目。CMake的详细指令如下：</p>
<pre><code>Generate a Project Buildsystem
 cmake [&lt;options&gt;] &lt;path-to-source&gt;
 cmake [&lt;options&gt;] &lt;path-to-existing-build&gt;
 cmake [&lt;options&gt;] -S &lt;path-to-source&gt; -B &lt;path-to-build&gt;

Build a Project
 cmake --build &lt;dir&gt; [&lt;options&gt;] [-- &lt;build-tool-options&gt;]

Install a Project
 cmake --install &lt;dir&gt; [&lt;options&gt;]

Open a Project
 cmake --open &lt;dir&gt;

Run a Script
 cmake [{-D &lt;var&gt;=&lt;value&gt;}...] -P &lt;cmake-script-file&gt;

Run a Command-Line Tool
 cmake -E &lt;command&gt; [&lt;options&gt;]

Run the Find-Package Tool
 cmake --find-package [&lt;options&gt;]

View Help
 cmake --help[-&lt;topic&gt;]</code></pre>
<h3 id="cmake-命令基础">CMAKE 命令基础</h3>
<p>除了命令行可以跨平台以外，为了生成不同的Build System脚本，CMake还发展了一套自己的语言来指导其生成<code>make</code>文件或<code>sln</code>文件等。一个最简单的版本是</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">cmake_minimum_required</span> (<span class="ot">VERSION</span> <span class="dt">2.6</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="kw">project</span>(HelloWorld)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="kw">add_executable</span> (Hello Hello.cpp)</span></code></pre></div>
<p>我们需要将这三行放入根目录下一个叫<code>CMakeLists.txt</code>的文本文件当中，然后用上面的cmake命令来生成<code>Makefile</code>和进一步的可执行文件。</p>
<p>第一行指定了CMake的最低版本，第二行为该项目取了名字，而第三行则增加了一个可执行文件类型的<code>target</code>，其名称为<code>Hello</code>，其源文件是<code>Hello.cpp</code>。如果在Windows下执行，会生成一个exe文件，如果是Linux则是正常的可执行文件。target的类型除了可执行文件，也可以是其他，比如使用<code>add_library()</code>来生成一个库。</p>
<p>在CMake 3.0 版本之前，CMake的指令是都需要大写的，写起来就像是被自己的代码骂了一顿。而3.0之后，CMake的指令直接是大小写无关的了，也就是说<code>AdD_ExEcUtAbLe</code>和<code>add_executable</code>没有任何区别。当然这只适用于CMAKE指令，其余部分如变量名，文件名大小写还是正常的。</p>
<p>CMake最重要的部分可能就是变量的定义，简单变量可以通过如下方式定义：</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span>(my_variable <span class="st">&quot;a string value&quot;</span>)</span></code></pre></div>
<p>变量的类型可以是<code>STRING</code>,<code>PATH</code>,<code>BOOL</code>等等。但是如此定义出的变量只能是局部变量，其只可以被自己和自己的子文件夹使用，并且在本次CMAKE结束后会被删掉。</p>
<p>与之相对的是全局变量，全局变量会被保存到一个<code>CMakecache.txt</code>文件当中，故而全局都能看到，且运行后不会被删除。其定义需要使用</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span>(my_variable <span class="st">&quot;a string value&quot;</span> <span class="ot">CACHE</span> <span class="ot">STRING</span> <span class="st">&quot;description of this variable&quot;</span>)</span></code></pre></div>
<p><code>CACHE</code>表示这是各全局变量，<code>STRING</code>表示这个变量要以什么类型存储到CACHE中，这是有用的，因为<code>"a;b"</code>这种字符串会被CMake默认解析成列表<code>[a,b]</code>，而有时我们想要其为字符串。</p>
<p>但是<code>CACHE</code>默认是每个变量只被写一次的，这样可以避免重复写入带来的误差。也就是说，当定义全局变量时，如果<code>CACHE</code>里已经有这个变量了，那么新的定义就会失效，变量维持之前的值。如果想保证自己的修改一定生效，可以在括号的最后加入<code>FORCE</code>。</p>
<p>下面是一个<code>CACHE</code>的例子</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">cmake_minimum_required</span>(<span class="ot">VERSION</span> <span class="dt">2.4</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="kw">project</span>(VariablesTest)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span>(VAR <span class="st">&quot;CACHED-init&quot;</span> <span class="ot">CACHE</span> <span class="ot">STRING</span> <span class="st">&quot;A test&quot;</span>)</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="kw">message</span>(<span class="st">&quot;VAR = </span><span class="dv">${VAR}</span><span class="st">&quot;</span>)</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span>(VAR <span class="st">&quot;NORMAL&quot;</span>)</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="kw">message</span>(<span class="st">&quot;VAR = </span><span class="dv">${VAR}</span><span class="st">&quot;</span>)</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span>(VAR <span class="st">&quot;CACHED&quot;</span> <span class="ot">CACHE</span> <span class="ot">STRING</span> <span class="st">&quot;A test&quot;</span> <span class="ot">FORCE</span>)</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a><span class="kw">message</span>(<span class="st">&quot;VAR = </span><span class="dv">${VAR}</span><span class="st">&quot;</span>)</span></code></pre></div>
<p>如果我们连续执行两次，会因为第一个set没加<code>FORCE</code>而出现不同的结果</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 第一次运行结果</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="fu">VAR = CACHED-init</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="fu">VAR = NORMAL</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="fu">VAR = CACHED</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="fu"># 第二次运行结果</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="fu">VAR = CACHED</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="fu">VAR = NORMAL</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a><span class="fu">VAR = CACHED</span></span></code></pre></div>
<p>此外本例子还可以看出，全局变量和局部变量共存时，是以局部变量为准的。 ### CMAKE GUI</p>
<p>为了体现CACHE的重要性，我们插播一段Cmake的图形化使用。</p>
<p>虽然正常来讲<code>CMake</code>的执行只需要一句<code>cmake ..</code>，但是很多情况下我们需要手动给它指定一些参数，比如<code>Debug</code>还是<code>Release</code>，生成文件输出到哪里，或者为了能够在不同的环境下运行，需要让用户自己指定依赖的库的位置。</p>
<p>这种变量和CACHE的设计是十分吻合的，因为一个用户设置一次后很少会动这些设置，故而最好把它们缓存起来。但是这些变量往往又都隐藏在很长的<code>CMakeLists.txt</code>中，让用户自己把它们找出来并一次次修改又不大可能，故而此时一般使用图形化的方法给用户列出这些可交互的变量。</p>
<p>只需要在<code>build</code>文件夹下，用命令行键入<code>cmake-gui</code>（在支持QT的平台如Windows）或<code>ccmake</code>（支持<code>curses</code>库的平台如Linux），就会出现图形化的界面。</p>
<figure>
<img src="../figures/cmake-gui.png" alt="cmake-gui" /><figcaption aria-hidden="true">cmake-gui</figcaption>
</figure>
<figure>
<img src="../figures/ccmake.png" alt="ccmake" /><figcaption aria-hidden="true">ccmake</figcaption>
</figure>
<p>二者的使用大同小异，我们以<code>cmake-gui</code>为主介绍。</p>
<p>最上方部分是两个路径，分别是源文件路径和build路径，如果是从命令行调用的<code>cmake ..</code>，会分别设为上一级路径和当且路径。</p>
<figure>
<img src="../figures/cmake_path.png" alt="cmake-path" /><figcaption aria-hidden="true">cmake-path</figcaption>
</figure>
<p>中间部分是一些CACHE变量，用户可以更改这些变量。每次更改后需要交给CAMKE重新执行一次，这是通过点击下方的<code>Configure</code>按钮进行的。点击后<code>CMake</code>会按新的配置尝试一次，有可能生成新的需要配置的东西(比如<code>Release</code>模式会比<code>Debug</code>多了一些依赖库设置)，会用红色标记出来，用户需要对这些新的变量进行设置，然后再按<code>Configure</code>，如此进行直到没有新的红色为止。最后点击<code>Generate</code>进行真正的<code>cmake</code>，从而生成<code>Makefile</code>或者<code>sln</code>。（妈妈再也不用担心我成不了<code>CMake</code>大师啦x）</p>
<h3 id="生成configure文件">生成Configure文件</h3>
<p>有些时候我们的源代码也需要一些位置信息，我们会将其保存在一个头文件里，比如定义一个<code>config.h</code>文件</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define PATH_DATA </span><span class="st">&quot;/home/user/projects/myproject/data&quot;</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define THIRDPARTIES_PATH </span><span class="st">&quot;/home/user/projects/myproject/thirdparties&quot;</span></span></code></pre></div>
<p>这里使用的是绝对路径，不方便移植到其他电脑上，也无法加入到<code>git</code>中（不同的用户同时使用会conflict）。从而CMake对其进行了一次抽象，表示<code>config.h</code>文件可以从<code>config.h.in</code>文件中生成出来</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>cmakedefine PATH_DATA <span class="st">&quot;@myproject_DATA@&quot;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>cmakedefine THIRDPARTIES_PATH <span class="st">&quot;@THIRDPARTIES_PATH@&quot;</span></span></code></pre></div>
<p>这个<code>.in</code>文件是不依赖于环境的，从而可以放入git中。这个项目的<code>CMakeLists.txt</code>大概像下面的样子</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CMAKE_MINIMUM_REQUIRED</span>(<span class="ot">VERSION</span> <span class="dt">2.8.11</span>)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="kw">SET</span>(PROJ_NAME <span class="st">&quot;myproject&quot;</span>)</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="kw">PROJECT</span>(<span class="dv">${PROJ_NAME}</span>)</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a><span class="kw">SET</span>(<span class="dv">${PROJ_NAME}</span><span class="va">_DATA</span> <span class="st">&quot;&quot;</span> <span class="ot">CACHE</span> <span class="ot">PATH</span> <span class="st">&quot;DATA and RESOURCES&quot;</span>) </span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a><span class="kw">SET</span>(THIRDPARTIES_PATH <span class="dv">${CMAKE_CURRENT_SOURCE_DIR}</span>/../thirdparties <span class="ot">CACHE</span> <span class="ot">PATH</span> <span class="st">&quot;thirdparties&quot;</span>)</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a><span class="kw">configure_file</span>(config.h.in config.h )</span></code></pre></div>
<p>两个<code>SET</code>命令定义了<code>.in</code>文件中需要的变量。最后的<code>configure</code>命令则执行了生成<code>.h</code>的过程。</p>
<h3 id="包查询和包管理">包查询和包管理</h3>
<p>我们的项目一般都会需要使用一些包，我们需要在<code>CMake</code>中将其和我们的可执行文件链接起来。下面是一个简单的例子</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co">// for mysqrt.cpp</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> my_sqrt<span class="op">(</span><span class="dt">double</span> num<span class="op">){</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">double</span> err <span class="op">=</span> <span class="fl">1e-8</span><span class="op">;</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>num <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> root <span class="op">=</span> num<span class="op">;</span></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>num <span class="op">-</span> root <span class="op">*</span> root <span class="op">&gt;=</span> err <span class="op">||</span> root<span class="op">*</span>root <span class="op">-</span> num <span class="op">&gt;=</span> err<span class="op">)</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>            root <span class="op">=</span> <span class="op">(</span>num <span class="op">/</span> root <span class="op">+</span> root<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> root<span class="op">;</span></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a><span class="co">//for main.cpp</span></span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="dt">double</span> my_sqrt<span class="op">(</span><span class="dt">double</span><span class="op">);</span></span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>my_sqrt<span class="op">(</span><span class="dv">50</span><span class="op">)&lt;&lt;</span><span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb57-28"><a href="#cb57-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb57-29"><a href="#cb57-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CMAKE_MINIMUM_REQUIRED</span>(<span class="ot">VERSION</span> <span class="dt">3.0</span>)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="kw">project</span>(HelloMath)</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="kw">add_library</span>(math mysqrt.cpp)</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="kw">add_executable</span>(sqrt50 main.cpp)</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="kw">target_link_libraries</span>(sqrt50 <span class="ot">PUBLIC</span> math)</span></code></pre></div>
<p>这个例子中我们使用的包是自己生成的，我们可以默认<code>CMake</code>能找到它的路径。但是很多情况下我们需要使用第三方包，它们可能以源代码的形式储存在项目里，可能是安装到了某个路径，也可能被包管理器包装起来了，这时候我们需要想办法让<code>CMake</code>找到这些包。</p>
<p>一个常用的方法是使用<code>find_package(xxx)</code>命令，它会调用一个<code>xxx.cmake</code>文件，里面包含了库<code>xxx</code>的搜索方法。CMake本身包含了很多库的find.cmake，如果没提供的话可能得自己写。</p>
<p>Linux下还可以使用<code>pkg_search_module(xxx)</code>，它需要的是有这个库的<code>.pc</code>文件。下面是一个Linux下使用Eigen的例子</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">cmake_minimum_required</span>(<span class="ot">VERSION</span> <span class="dt">3.0</span>)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="kw">project</span>(<span class="st">&quot;EigenTest&quot;</span>)</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="kw">find_package</span>(PkgConfig)</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="fu">pkg_search_module</span>(Eigen3 REQUIRED eigen3)</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="kw">include_directories</span>(<span class="dv">${Eigen3_INCLUDE_DIRS}</span>)</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a><span class="kw">add_executable</span>(eigentest main.cpp)</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="kw">target_link_libraries</span>(eigentest <span class="dv">${Eigen3_INCLUDE_DIRS}</span>)</span></code></pre></div>
<p>但实际上我们有更好的选择，就是使用<code>vcpkg</code>包管理器帮我们查找这些包的位置。vcpkg是微软的跨平台包管理器，其配置使用都比较方便。</p>
<p>vcpkg的github网址是<a href="https://github.com/microsoft/vcpkg">这里</a>。以Windows为例，你只需要在任意位置，简单地clone一份源代码，进入其目录，然后执行</p>
<pre class="cmd"><code>.\vcpkg\bootstrap-vcpkg.bat</code></pre>
<p>该目录下回生成<code>vcpkg.exe</code>，这就是我们用来交互的程序。 安装包只需要在该目录下执行</p>
<pre class="cmd"><code>.\vcpkg.exe install xxx</code></pre>
<p>一般默认安装<code>x86</code>版本的，如果想要指定包的安装平台，可以有两种方式指定</p>
<pre class="cmd"><code>&gt; .\vcpkg.exe install package:x64-windows
&gt; .\vcpkg.exe install [packages to install] --triplet=x64-windows</code></pre>
<p>比如安装<code>eigen3</code></p>
<pre class="cmd"><code>&gt; .\vcpkg.exe install eigen3:x64-windows
......
The package eigen3:x64-windows provides CMake targets:

    find_package(Eigen3 CONFIG REQUIRED)
    target_link_libraries(main PRIVATE Eigen3::Eigen)</code></pre>
<p>在很长的输出信息后，它会告诉你如何在CMake中使用这个包，我们可以尝试一下。</p>
<pre><code>cmake_minimum_required(VERSION 3.0)

set(CMAKE_TOOLCHAIN_FILE ${CMAKE_CURRENT_SOURCE_DIR}/vcpkg/scripts/buildsystems/vcpkg.cmake CACHE STRING &quot;Vcpkg toolchain file&quot;)

project(&quot;EigenTest&quot;)

find_package(Eigen3 CONFIG REQUIRED)

add_executable(eigentest main.cpp)
target_link_libraries(eigentest Eigen3::Eigen)</code></pre>
<p>之后我们指定使用<code>x64</code>平台生成即可</p>
<pre><code>&gt; cmake -A x64 ..
&gt; cmake --build</code></pre>
<p>最后一点，如果直接使用Visual Studio管理项目而不使用CMake的话，可以使用</p>
<pre><code>.\vcpkg.exe integrate install</code></pre>
<p>这会让你可以直接在Visual Studio中使用安装好的包。但是卸载的时候需要先取消integrate，然后再删除vcpkg。</p>
<h1 id="参考链接">参考链接</h1>
<p><a href="https://julienjorge.medium.com/an-overview-of-build-systems-mostly-for-c-projects-ac9931494444">An overview of build systems</a></p>
<p><a href="https://www.gnu.org/software/make/manual/">Make Document</a></p>
<p><a href="https://missing.csail.mit.edu/2020/metaprogramming/">Meta Programming</a></p>
<p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">CMAKE tutorial</a></p>
<p><a href="https://riptutorial.com/ebook/cmake">CMAKE RIP tutorial</a></p>
<p><a href="https://www.youtube.com/watch?v=V1YP7eJHDJE">How to CMake Good</a></p>
<p><a href="https://github.com/microsoft/vcpkg">vcpkg document</a></p>                    
                </div>
            </div>

            <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>
        </div>
    </body>
</html>
